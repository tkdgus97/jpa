## 3장 - 영속성 관리

### 영속성 컨텍스트?
- 직역하면 엔티티를 영구 저장하는 환경
- 엔티티 매니저로 엔티티를 저장하거나 조회 시 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관, 관리
- 11장에서 자세히...

### 생명주기
- 영속 
  - 영속성 컨텍스트에 저장된 상태
  - 엔티티 매니저가 조회하거나 JPQL을 사용해서 조회한 엔티티 등
- 비영속
  - 영속성 컨텍스트와 전혀 관계없는 상태
- 준영속
  - 저장되었다가 분리된 상태
  - detach() 메소드를 통해 준영속 상태 가능
- 삭제
  - 삭제된 상태

### 특징
- 엔티티를 식별자 값(@ID)로 구분한다. 따라서 식별자값 반드시 필요
- 보통 트랜잭선을 commit 하는 시점에 DB에 저장된다. 이것을 플러시라고 한다.
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 지연 로딩


### 1차 캐시 
영속성 컨텍스트는 내부에 캐시를 가진다. 이것을 **1차 캐시**라고 하며 영속 상태에 해당하는 엔티티는 모두
이곳에 저장된다.
```java
em.persist(member);
```
- persist를 호출한다고 해서 DB에 반영되지 않는다. 대신 영속성 컨텍스트에 저장되며 컨텍스트 내부에 1차 캐시에 식별자 값을 key값으로 엔티티 정보가 저장된다
- find시에 1차 캐시에 존재한다면 쿼리를 날리지 않고 바로 찾은 엔티티를 주지만 없다면 DB에서 조회한다. 이후 영속 상태로 만든다.
- 1차 캐시를 통해 DB 조회를 거치는 작업을 생략하는 등 성능상의 이점을 가져갈 수 있다. 또한 엔티티의 동일성을 보장한다.

### 트랜잭션을 지원하는 쓰기 지연
엔티티 매니저는 커밋 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둔다.  
이후 커밋 시에 쿼리를 DB로 보내며 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.  

### 변경 감지
기존의 SQL을 활용한 수정 작업은 UPDATE SQL을 통해 작성했다.  
하지만 요구사항이 늘어나거나 프로젝트가 점점 커지면서 수정쿼리가 증가하거나 SQL을 지속적으로 확인해야 하는 번거로움이 생긴다.  

JPA는 **변경 감지**를 통해 엔티티의 변경 사항을 DB에 자동으로 반영한다.  
참고로 변경 감지는 영속 상태에 해당하는 엔티티에만 적용된다.

변경 감지는 다음의 과정들로 이루어진다
1. 영속 상태 시 최초 상태 스냅샷을 저장
2. 플러시 호출
3. 스냅샷을 통해 변경된 엔티티 조회
4. 변경된 엔티티가 존재할 경우 수정 쿼리 생성 후 쓰기 지연 SQL에 저장
5. SQL을 DB로 전달
6. 트랜잭션 커밋

### 플러시
플런시란 컨텍스트의 변경 내용을 DB에 반영한다.  
영속성 컨텍스트를 플러시하는 방법은 3가지이다.  
- 엔티티 매니저의 flush()
- 트랜잭션 커밋 시
  - 커밋 시에도 flush를 호출하지 않으면 SQL이 전달되지 않는다. 따라서 꼭 flush를 호출해야됨
- JPQL 쿼리 실행 시
  - JPQL은 SQL로 변한되어 DB에서 엔티티를 조회한다. 
  - 하지만 영속 상태로만 존재하는 엔티티들은 조회되지 않기에 flush를 호출하여 반영 후 조회 한다.